[
{"name": "microcontroller.Processor", "args": [], "description": ""},
{"name": "microcontroller.Pin", "args": [], "description": "Identifies an IO pin on the microcontroller. They are fixed by the\nhardware so they cannot be constructed on demand. Instead, use\nboard or microcontroller.pin to reference the desired pin.\n\n"},
{"name": "multiterminal.get_secondary_terminal", "args": [], "description": "Returns the current secondary terminal.\n"},
{"name": "multiterminal.set_secondary_terminal", "args": ["stream"], "description": "Read additional input from the given stream and write out back to it.\nThis doesn\u2019t replace the core stream (usually UART or native USB) but is\nmixed in instead.\n\n\n\n\nParameters:stream (stream) \u2013 secondary stream\n\n\n\n"},
{"name": "multiterminal.clear_secondary_terminal", "args": [], "description": "Clears the secondary terminal.\n"},
{"name": "multiterminal.schedule_secondary_terminal_read", "args": ["socket"], "description": "In cases where the underlying OS is doing task scheduling, this notifies\nthe OS when more data is available on the socket to read. This is useful\nas a callback for lwip sockets.\n"},
{"name": "pulseio.PulseIn", "args": ["pin", "maxlen=2", "*", "idle_state=False"], "description": "Create a PulseIn object associated with the given pin. The object acts as\na read-only sequence of pulse lengths with a given max length. When it is\nactive, new pulse lengths are added to the end of the list. When there is\nno more room (len() == maxlen) the oldest pulse length is removed to\nmake room.\n\n\nParameters:\npin (Pin) \u2013 Pin to read pulses from.\nmaxlen (int) \u2013 Maximum number of pulse durations to store at once\nidle_state (bool) \u2013 Idle state of the pin. At start and after resume\nthe first recorded pulse will the opposite state from idle."},
{"name": "pulseio.PulseIn.deinit", "args": [], "description": "Deinitialises the PulseIn and releases any hardware resources for reuse.\n"},
{"name": "pulseio.PulseIn.maxlen", "args": null, "description": "Returns the maximum length of the PulseIn. When len() is equal to maxlen,\nit is unclear which pulses are active and which are idle.\n"},
{"name": "os.uname", "args": [], "description": "Returns a named tuple of operating specific and CircuitPython port\nspecific information.\n"},
{"name": "os.chdir", "args": ["path"], "description": "Change current directory.\n"},
{"name": "os.getcwd", "args": [], "description": "Get the current directory.\n"},
{"name": "os.listdir", "args": ["dir"], "description": "With no argument, list the current directory.  Otherwise list the given directory.\n"},
{"name": "os.mkdir", "args": ["path"], "description": "Create a new directory.\n"},
{"name": "os.remove", "args": ["path"], "description": "Remove a file.\n"},
{"name": "os.rmdir", "args": ["path"], "description": "Remove a directory.\n"},
{"name": "nvm.ByteArray", "args": [], "description": "Not currently dynamically supported. Access the sole instance through microcontroller.nvm.\n\n"},
{"name": "os.rename", "args": ["old_path", "new_path"], "description": "Rename a file.\n"},
{"name": "os.stat", "args": ["path"], "description": "Get the status of a file or directory.\n"},
{"name": "os.statvfs", "args": ["path"], "description": "Get the status of a fileystem.\nReturns a tuple with the filesystem information in the following order:\n\n\nf_bsize \u2013 file system block size\nf_frsize \u2013 fragment size\nf_blocks \u2013 size of fs in f_frsize units\nf_bfree \u2013 number of free blocks\nf_bavail \u2013 number of free blocks for unpriviliged users\nf_files \u2013 number of inodes\nf_ffree \u2013 number of free inodes\nf_favail \u2013 number of free inodes for unpriviliged users\nf_flag \u2013 mount flags\nf_namemax \u2013 maximum filename length\n\n\nParameters related to inodes: f_files, f_ffree, f_avail\nand the f_flags parameter may return 0 as they can be unavailable\nin a port-specific implementation.\n"},
{"name": "os.sync", "args": [], "description": "Sync all filesystems.\n"},
{"name": "os.urandom", "args": ["size"], "description": "Returns a string of size random bytes based on a hardware True Random\nNumber Generator. When not available, it will raise a NotImplementedError.\n"},
{"name": "digitalio.Pull", "args": [], "description": "Enum-like class to define the pull value, if any, used while reading\ndigital values in.\n\n"},
{"name": "digitalio.Pull.UP", "args": null, "description": "When the input line isn\u2019t being driven the pull up can pull the state\nof the line high so it reads as true.\n"},
{"name": "digitalio.Pull.DOWN", "args": null, "description": "When the input line isn\u2019t being driven the pull down can pull the\nstate of the line low so it reads as false.\n"},
{"name": "digitalio.DriveMode", "args": [], "description": "Enum-like class to define the drive mode used when outputting\ndigital values.\n\n"},
{"name": "digitalio.DriveMode.PUSH_PULL", "args": null, "description": "Output both high and low digital values\n"},
{"name": "digitalio.DriveMode.OPEN_DRAIN", "args": null, "description": "Output low digital values but go into high z for digital high. This is\nuseful for i2c and other protocols that share a digital line.\n"},
{"name": "digitalio.DigitalInOut", "args": ["pin"], "description": "Create a new DigitalInOut object associated with the pin. Defaults to input\nwith no pull. Use switch_to_input() and\nswitch_to_output() to change the direction.\n\n\nParameters:pin (Pin) \u2013 The pin to control"},
{"name": "digitalio.DigitalInOut.Direction", "args": [], "description": "Enum-like class to define which direction the digital values are\ngoing.\n\n"},
{"name": "digitalio.DigitalInOut.Direction.INPUT", "args": null, "description": "Read digital data in\n"},
{"name": "digitalio.DigitalInOut.Direction.OUTPUT", "args": null, "description": "Write digital data out\n"},
{"name": "digitalio.DigitalInOut.deinit", "args": [], "description": "Turn off the DigitalInOut and release the pin for other use.\n"},
{"name": "digitalio.DigitalInOut.direction", "args": null, "description": "The direction of the pin.\nSetting this will use the defaults from the corresponding\nswitch_to_input() or switch_to_output() method. If\nyou want to set pull, value or drive mode prior to switching, then use\nthose methods instead.\n"},
{"name": "digitalio.DigitalInOut.value", "args": null, "description": "The digital logic level of the pin.\n"},
{"name": "digitalio.DigitalInOut.drive_mode", "args": null, "description": "Get or set the pin drive mode.\n"},
{"name": "digitalio.DigitalInOut.pull", "args": null, "description": "Get or set the pin pull. Values may be digitalio.Pull.UP,\ndigitalio.Pull.DOWN or None.\n\n\n\n\nRaises:AttributeError \u2013 if the direction is ~`digitalio.Direction.OUTPUT`.\n\n\n\n"},
{"name": "usb_hid.Device", "args": [], "description": "Not currently dynamically supported.\n\n"},
{"name": "usb_hid.Device.send_report", "args": ["buf"], "description": "Send a HID report.\n"},
{"name": "usb_hid.Device.usage_page", "args": null, "description": "The usage page of the device. Can be thought of a category.\n\n\n\n\nReturns:the device\u2019s usage page\n\nReturn type:int\n\n\n\n"},
{"name": "usb_hid.Device.usage", "args": null, "description": "The functionality of the device. For example Keyboard is 0x06 within the\ngeneric desktop usage page 0x01. Mouse is 0x02 within the same usage\npage.\n\n\n\n\nReturns:the usage within the usage page\n\nReturn type:int\n\n\n\n"},
{"name": "touchio.TouchIn", "args": ["pin"], "description": "Use the TouchIn on the given pin.\n\n\nParameters:pin (Pin) \u2013 the pin to read from"},
{"name": "touchio.TouchIn.deinit", "args": [], "description": "Deinitialises the TouchIn and releases any hardware resources for reuse.\n"},
{"name": "touchio.TouchIn.value", "args": null, "description": "Whether the touch pad is being touched or not.\n\n\n\n\nReturns:True when touched, False otherwise.\n\nReturn type:bool\n\n\n\n"},
{"name": "time.struct_time", "args": ["(tm_year", "tm_mon", "tm_mday", "tm_hour", "tm_min", "tm_sec", "tm_wday", "tm_yday", "tm_isdst)"], "description": "Structure used to capture a date and time. Note that it takes a tuple!\n\n\nParameters:\ntm_year (int) \u2013 the year, 2017 for example\ntm_mon (int) \u2013 the month, range [1, 12]\ntm_mday (int) \u2013 the day of the month, range [1, 31]\ntm_hour (int) \u2013 the hour, range [0, 23]\ntm_min (int) \u2013 the minute, range [0, 59]\ntm_sec (int) \u2013 the second, range [0, 61]\ntm_wday (int) \u2013 the day of the week, range [0, 6], Monday is 0\ntm_yday (int) \u2013 the day of the year, range [1, 366], -1 indicates not known\ntm_isdst (int) \u2013 1 when in daylight savings, 0 when not, -1 if unknown."},
{"name": "storage.mount", "args": ["filesystem", "mount_path", "*", "readonly=False"], "description": "Mounts the given filesystem object at the given path.\nThis is the CircuitPython analog to the UNIX mount command.\n"},
{"name": "storage.umount", "args": ["mount"], "description": "Unmounts the given filesystem object or if mount is a path, then unmount\nthe filesystem mounted at that location.\nThis is the CircuitPython analog to the UNIX umount command.\n"},
{"name": "storage.remount", "args": ["mount_path", "readonly"], "description": "Remounts the given path with new parameters.\n"},
{"name": "storage.VfsFat", "args": ["block_device"], "description": "Create a new VfsFat filesystem around the given block device.\n\n\nParameters:block_device \u2013 Block device the the filesystem lives on"},
{"name": "pulseio.PWMOut", "args": ["pin", "*", "duty_cycle=0", "frequency=500", "variable_frequency=False"], "description": "Create a PWM object associated with the given pin. This allows you to\nwrite PWM signals out on the given pin. Frequency is fixed after init\nunless variable_frequency is True.\n\n\nParameters:\npin (Pin) \u2013 The pin to output to\nduty_cycle (int) \u2013 The fraction of each pulse which is high. 16-bit\nfrequency (int) \u2013 The target frequency in Hertz (32-bit)\nvariable_frequency (bool) \u2013 True if the frequency will change over time"},
{"name": "pulseio.PulseOut", "args": ["carrier"], "description": "Create a PulseOut object associated with the given PWM out experience.\n\n\nParameters:carrier (PWMOut) \u2013 PWMOut that is set to output on the desired pin."},
{"name": "pulseio.PWMOut.deinit", "args": [], "description": "Deinitialises the PWMOut and releases any hardware resources for reuse.\n"},
{"name": "pulseio.PWMOut.duty_cycle", "args": null, "description": "16 bit value that dictates how much of one cycle is high (1) versus low\n(0). 0xffff will always be high, 0 will always be low and 0x7fff will\nbe half high and then half low.\n"},
{"name": "pulseio.PWMOut.frequency", "args": null, "description": "32 bit value that dictates the PWM frequency in Hertz (cycles per\nsecond). Only writeable when constructed with variable_frequency=True.\n"},
{"name": "random.seed", "args": ["seed"], "description": "Sets the starting seed of the random  number generation. Further calls to\nrandom will return deterministic results afterwards.\n"},
{"name": "random.getrandbits", "args": ["k"], "description": "Returns an integer with k random bits.\n"},
{"name": "random.randrange", "args": ["stop"], "description": "Returns a randomly selected integer from range(start, stop, step).\n"},
{"name": "random.randint", "args": ["a", "b"], "description": "Returns a randomly selected integer between a and b inclusive. Equivalent\nto randrange(a, b + 1, 1)\n"},
{"name": "random.choice", "args": ["seq"], "description": "Returns a randomly selected element from the given sequence. Raises\nIndexError when the sequence is empty.\n"},
{"name": "random.random", "args": [], "description": "Returns a random float between 0 and 1.0.\n"},
{"name": "pulseio.PulseOut.deinit", "args": [], "description": "Deinitialises the PulseOut and releases any hardware resources for reuse.\n"},
{"name": "random.uniform", "args": ["a", "b"], "description": "Returns a random float between a and b. It may or may not be inclusive\ndepending on float rounding.\n"},
{"name": "busio.UART", "args": ["tx", "rx", "*", "baudrate=9600", "bits=8", "parity=None", "stop=1", "timeout=1000", "receiver_buffer_size=64"], "description": "A common bidirectional serial protocol that uses an an agreed upon speed\nrather than a shared clock line.\n\n\nParameters:\ntx (Pin) \u2013 the pin to transmit with\nrx (Pin) \u2013 the pin to receive on\nbaudrate (int) \u2013 the transmit and receive speed"},
{"name": "busio.SPI", "args": ["clock", "MOSI=None", "MISO=None"], "description": "\nParameters:\nclock (Pin) \u2013 the pin to use for the clock.\nMOSI (Pin) \u2013 the Master Out Slave In pin.\nMISO (Pin) \u2013 the Master In Slave Out pin."},
{"name": "busio.OneWire", "args": ["pin"], "description": "Create a OneWire object associated with the given pin. The object\nimplements the lowest level timing-sensitive bits of the protocol.\n\n\nParameters:pin (Pin) \u2013 Pin connected to the OneWire bus"},
{"name": "busio.OneWire.deinit", "args": [], "description": "Deinitialize the OneWire bus and release any hardware resources for reuse.\n"},
{"name": "busio.I2C", "args": ["scl", "sda", "*", "frequency=400000"], "description": "I2C is a two-wire protocol for communicating between devices.  At the\nphysical level it consists of 2 wires: SCL and SDA, the clock and data\nlines respectively.\n\n\nParameters:\nscl (Pin) \u2013 The clock pin\nsda (Pin) \u2013 The data pin\nfrequency (int) \u2013 The clock frequency in Hertz"},
{"name": "busio.UART.deinit", "args": [], "description": "Deinitialises the UART and releases any hardware resources for reuse.\n"},
{"name": "busio.UART.Parity", "args": [], "description": "Enum-like class to define the parity used to verify correct data transfer.\n\n"},
{"name": "busio.UART.Parity.ODD", "args": null, "description": "Total number of ones should be odd.\n"},
{"name": "busio.UART.Parity.EVEN", "args": null, "description": "Total number of ones should be even.\n"},
{"name": "busio.SPI.deinit", "args": [], "description": "Turn off the SPI bus.\n"},
{"name": "busio.I2C.deinit", "args": [], "description": "Releases control of the underlying hardware so other classes can use it.\n"},
{"name": "bitbangio.OneWire", "args": ["pin"], "description": "Create a OneWire object associated with the given pin. The object\nimplements the lowest level timing-sensitive bits of the protocol.\n\n\nParameters:pin (Pin) \u2013 Pin to read pulses from."},
{"name": "bitbangio.OneWire.deinit", "args": [], "description": "Deinitialize the OneWire bus and release any hardware resources for reuse.\n"},
{"name": "bitbangio.SPI", "args": ["clock", "MOSI=None", "MISO=None"], "description": "\nParameters:\nclock (Pin) \u2013 the pin to use for the clock.\nMOSI (Pin) \u2013 the Master Out Slave In pin.\nMISO (Pin) \u2013 the Master In Slave Out pin."},
{"name": "bitbangio.I2C", "args": ["scl", "sda", "*", "frequency=400000"], "description": "I2C is a two-wire protocol for communicating between devices.  At the\nphysical level it consists of 2 wires: SCL and SDA, the clock and data\nlines respectively.\n\n\nParameters:\nscl (Pin) \u2013 The clock pin\nsda (Pin) \u2013 The data pin\nfrequency (int) \u2013 The clock frequency of the bus"},
{"name": "bitbangio.SPI.deinit", "args": [], "description": "Turn off the SPI bus.\n"},
{"name": "bitbangio.I2C.deinit", "args": [], "description": "Releases control of the underlying hardware so other classes can use it.\n"},
{"name": "audioio.AudioOut", "args": ["pin", "sample_source"], "description": "Create a AudioOut object associated with the given pin. This allows you to\nplay audio signals out on the given pin. Sample_source must be a bytes-like object.\n\nThe sample itself should consist of 16 bit samples and be mono.\nMicrocontrollers with a lower output resolution will use the highest order\nbits to output. For example, the SAMD21 has a 10 bit DAC that ignores the\nlowest 6 bits when playing 16 bit samples.\n\n\nParameters:\npin (Pin) \u2013 The pin to output to\nsample_source (bytes-like) \u2013 The source of the sample"},
{"name": "audioio.AudioOut.deinit", "args": [], "description": "Deinitialises the PWMOut and releases any hardware resources for reuse.\n"},
{"name": "audioio.AudioOut.playing", "args": null, "description": "True when the audio sample is being output.\n"},
{"name": "audioio.AudioOut.frequency", "args": null, "description": "32 bit value that dictates how quickly samples are loaded into the DAC\nin Hertz (cycles per second). When the sample is looped, this can change\nthe pitch output without changing the underlying sample.\n"},
{"name": "audiobusio.PDMIn", "args": ["clock_pin", "data_pin", "*", "frequency=8000", "bit_depth=8", "mono=True", "oversample=64"], "description": "Create a PDMIn object associated with the given pins. This allows you to\nrecord audio signals from the given pins. Individual ports may put further\nrestrictions on the recording parameters.\n\n\nParameters:\nclock_pin (Pin) \u2013 The pin to output the clock to\ndata_pin (Pin) \u2013 The pin to read the data from\nfrequency (int) \u2013 Target frequency of the resulting samples. Check frequency for real value.\nbit_depth (int) \u2013 Final number of bits per sample. Must be divisible by 8\nmono (bool) \u2013 True when capturing a single channel of audio, captures two channels otherwise\noversample (int) \u2013 Number of single bit samples to decimate into a final sample. Must be divisible by 8"},
{"name": "audiobusio.PDMIn.deinit", "args": [], "description": "Deinitialises the PWMOut and releases any hardware resources for reuse.\n"},
{"name": "audiobusio.PDMIn.frequency", "args": null, "description": "The actual frequency of the recording. This may not match the constructed\nfrequency due to internal clock limitations.\n"},
{"name": "analogio.AnalogOut", "args": ["pin"], "description": "Use the AnalogOut on the given pin.\n\n\nParameters:pin (Pin) \u2013 the pin to output to"},
{"name": "analogio.AnalogOut.deinit", "args": [], "description": "Turn off the AnalogOut and release the pin for other use.\n"},
{"name": "analogio.AnalogOut.value", "args": null, "description": "The value on the analog pin.  The value must be between 0 and 65535\ninclusive (16-bit). Even if the underlying digital to analog converter\nis lower resolution, the input must be scaled to be 16-bit.\n\n\n\n\nReturns:the last value written\n\nReturn type:int\n\n\n\n"},
{"name": "analogio.AnalogIn", "args": ["pin"], "description": "Use the AnalogIn on the given pin. The reference voltage varies by\nplatform so use reference_voltage to read the configured setting.\n\n\nParameters:pin (Pin) \u2013 the pin to read from"},
{"name": "analogio.AnalogIn.deinit", "args": [], "description": "Turn off the AnalogIn and release the pin for other use.\n"},
{"name": "analogio.AnalogIn.value", "args": null, "description": "Read the value on the analog pin and return it.  The returned value\nwill be between 0 and 65535 inclusive (16-bit). Even if the underlying\nanalog to digital converter (ADC) is lower resolution, the result will\nbe scaled to be 16-bit.\n\n\n\n\nReturns:the data read\n\nReturn type:int\n\n\n\n"},
{"name": "analogio.AnalogIn.reference_voltage", "args": null, "description": "The maximum voltage measurable. Also known as the reference voltage.\n\n\n\n\nReturns:the reference voltage\n\nReturn type:float\n\n\n\n"}
]